package com.artu.controller;


// 컨트롤러의 주요 역할은 클라이언트의 요청을 받아서 유효성을 검증하고, 적절한 서비스 계층을 호출한 뒤, 그 결과를 클라이언트에게 응답으로 반환하는 것입니다.
// 컨트롤러는 비즈니스 로직을 직접 처리하지 않습니다.


public class UserAccountController {
}

/*
컨트롤러와 서비스 계층의 역할 분리 (회원가입 예시)!!!

1. 컨트롤러에서 할 일:

    요청 수신 및 DTO 매핑:
        클라이언트로부터 HTTP POST 요청(폼 데이터)을 받아서 SignupRequestDto 객체로 매핑합니다.
        (Spring의 @RequestBody나 @ModelAttribute를 통해 자동으로 처리됩니다.)

    1차 유효성 검증 (DTO 형식 검증):
        DTO에 @NotBlank, @Email, @Size 등 Jakarta Validation (Bean Validation) 어노테이션을 사용하여 데이터의 형식이 올바른지,
        필드가 비어있지 않은지 등의 기본적인 유효성 검사를 수행합니다.
        이는 HTTP 요청 자체의 유효성(예: 필드 누락, 잘못된 형식)을 확인하여 불필요한 서비스 계층 호출을 막습니다.
        예시: userId가 비어있는 경우, @NotBlank가 이를 잡아내어 컨트롤러 레벨에서 바로 오류 응답을 보낼 수 있습니다.

    서비스 계층 호출:
        유효성 검사를 통과한 SignupRequestDto 객체를 UserAccountService의 registerUser 메서드에 전달합니다.

    응답 반환:
        서비스 계층으로부터 받은 결과를 적절한 HTTP 응답(예: 201 Created와 함께 생성된 사용자 정보 DTO)으로 변환하여 클라이언트에게 전송합니다.
        서비스 계층에서 발생한 예외를 적절히 처리하여 HTTP 상태 코드(예: 400 Bad Request, 409 Conflict)와 오류 메시지를 반환합니다.

컨트롤러에서 하지 않을 일:
    비즈니스 로직(예: 비밀번호 암호화, 데이터베이스 저장).
    데이터 중복 확인(이메일, 아이디 중복 확인 등)과 같은 도메인 특화된 유효성 검사.


2. 서비스에서 할 일:

    2차 유효성 검증 (도메인/비즈니스 유효성 검증):
        userId 또는 email의 중복 여부 확인과 같이 데이터베이스에 접근하여 확인해야 하는 비즈니스 규칙 관련 유효성 검사를 수행합니다.
        닉네임 변경 가능 규칙에 따라 회원가입 시 닉네임 중복을 허용할지 등의 비즈니스 로직을 여기서 결정하고 검증합니다.
    DTO -> 엔티티 매핑:
        MapStruct를 사용하여 SignupRequestDto를 User 엔티티로 변환합니다.
        이때 DTO에 없는 필드(예: role, createdAt, isUsed)는 서비스 로직 내에서 기본값을 설정하거나 도메인 규칙에 따라 값을 할당합니다.

    비밀번호 암호화:
        받은 비밀번호를 PasswordEncoder를 사용하여 안전하게 암호화합니다.

    데이터베이스 저장:
        맵핑 및 암호화가 완료된 User 엔티티를 UserRepository를 통해 데이터베이스에 저장합니다.
        필요하다면 UserProfileRepository, UserStatsRepository 등 관련 테이블에 초기 데이터를 저장하는 로직도 여기서 처리합니다.

    트랜잭션 관리:
        @Transactional 어노테이션을 사용하여 여러 데이터베이스 작업(예: User 저장, UserProfile 저장)이 하나의 원자적인 단위로 처리되도록 보장합니다.
    예외 처리 및 비즈니스 결과 반환:
        비즈니스 규칙 위반(예: 중복 아이디) 시 특정 예외를 발생시키고, 성공 시에는 필요한 결과(예: 생성된 User 엔티티 또는 DTO)를 컨트롤러에 반환합니다.

서비스에서 하지 않을 일:
    HTTP 요청/응답 직접 처리.
*/
